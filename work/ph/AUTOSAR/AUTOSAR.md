# AUTOSAR

## 一、简介及目标

AUTOSAR是由全球各大汽车整车厂、汽车零部件供应商、汽车电子软件系统公司联合建立的一套标准协议，是对汽车技术开发一百多年来的经验总结。从2003年起，拟定了一个符合汽车电子软件开发的、开放的以及标准化的软件架构。该架构旨在改善汽车电子系统软件的更新与交换，同时更方便有效地管理日趋复杂的汽车电子软件系统。AUTOSAR规范的运用使得不同结构的电子控制单元的接口特征标椎化，应用软件具备更好的可扩展性以及可移植性，能够实现对现有软件的重用，大大降低了重复性工作，缩短开发周期。

AUTOSAR成员之间开展合作的主要目标是：使基本系统功能以及接口标椎化，使软件开发合作伙伴之间能交换、转换和集成各自的车载网络功能，最大限度地提高车辆售后的软件更新和系统升级效率。有了这个标准，AUTOSAR可以把范例从一个基于ECU的系统转移到基于功能的系统进行设计开发，统筹技术和经济方面对不断增长的E/E复杂性的汽车软件开发的管理。由于AUTOSAR提倡“在标准上合作，在实现上竞争”的原则，其核心思想是“统一标准、分散实施、集中配置”，所以采用AUTOSAR将为OEM带来很多好处，使得他们对于软件采购和控制拥有更大和更灵活的权利。软件系统的开放化和标准化将使更多的软件供应商进入汽车电子软件行业，OEM将有更多的选择，这将有利于提高软件产品的质量。

主要目标：

1. 建立分层的体系架构
2. 为应用程序的开发提供方法论
3. 制定各种应用接口规范

---

## 二、分层模型及标准化的应用接口

### AUTOSAR分层模型

为了实现应用程序和硬件模块之间的分离，汽车电子软件架构被抽象成四层

由上至下依次为：

- 应用层（Application Layer）
- 运行时环境（Run Time Environment,RTE）
- 基础软件层（Basic Software,BSW）
- 微控制器（Microcontroller）

![](https://s2.loli.net/2022/10/09/IxLZ5TMJH9R3wyt.png)

### 标准化的应用接口

通过RTE实现AUTOSAR软件组件之间以及应用层与基础软件之间的通信前提是：软件组件之间必须有标准的AUTOSAR接口。AUTOSAR规范把汽车电子领域内的一些典型的应用划分为若干个由一个或多个软件组件组成的模块，并详细定义了这些软件组件相关的参数，例如名称、范围、类型等。

AUTOSAR定义了三种接口：**标椎化接口（Standardized Interface）**、**AUTOSAR接口（AUTOSAR Interface）**和标准**化的AUTOSAR接口（Standardized AUTOSAR Interface）**。

**AUTOSAR接口**是一种与应用相关的接口，与RTE一并生成。基于AUTOSAR接口的端口可以用于软件组件（Software Component,SWC）之间或者软件组件与ECU固件之间（例如复杂驱动）的通信。

**标准化AUTOSAR接口**是一种特殊的AUTOSAR接口。这些在AUTOSAR规范中定义过的接口被SWC用于访问AUTOSAR BSW模块提供的服务，比如ECU管理模块或者诊断事件管理模块。

**标椎化接口**是AUTOSAR规范中用C语言定义的API。这些接口用于ECU内部BSW模块之间，RTE和操作系统之间或者RTE和COM模块之间。

![](https://s2.loli.net/2022/10/09/vnyuaN7bTCADH5q.png)

如图所示，基础软件之间通过标椎化接口进行数据通信和操作调用的。故基础软件之间可以相互调用各自的API函数，但是微控制器抽象层只能被ECU抽象层所调用，底层驱动信息通过ECU抽象层传递给服务层使用。

---

## 三、方法论

AUTOSAR为汽车电子软件系统开发过程定义了一套通用的技术方法，即AUTOSAR方法论。该方法描述了从系统底层配置到ECU可执行代码产生过程的设计步骤

![](https://s2.loli.net/2022/10/09/Q1dyIPj4woA3nkV.png)

**AUTOSAR设计和开发流程分为三个阶段：系统配置、ECU设计与配置阶段、代码生成阶段。**

**第一阶段：**定义系统配置文件，这是系统设计者或架构师的任务。包括选择硬件和软件组件，定义整个系统的约束条件。AUTOSAR通过使用信息交换格式和模板描述文件来减少初始系统设计时的工作量。系统配置的输入是XML类型的文件，输出是系统配置描述文件，系统配置的主要作用是把软件组件的需求映射到ECU上。

**第二阶段：**根据系统配置描述文件提取单个ECU资源相关的信息，提取出来的信息生成ECU提取文件。根据这个提取文件对ECU进行配置，例如操作系统任务调度，必要的BSW模块及其配置，运行实体到任务的分配等，从而生成ECU配置描述文件。该描述文件包含了特定ECU的所有信息。

**第三阶段：**生成代码，是基于ECU配置描述文件指定的配置来产生代码、编译代码，并把相关代码链接起来形成可执行文件。

***<u>具体开发流程如下：</u>***

1. 编写系统配置输入描述文件
   
   在AUTOSAR中，所有的描述文件都是XML类型的文件。系统配置输入文件包含三部分内容：
   - **软件组件描述**：定义了每个涉及的软件组件的接口内容，如数据类型，端口，接口等。
   - **ECU资源描述**：定义了每个ECU的资源需求，如处理器、存储器、外围设备、传感器和执行器等。
   - **系统约束描述**：定义了总线信号，软件组件间的拓扑结构和映射关系。
2. 系统配置
   
   系统配置的功能主要是在资源和时序关系的前提下，把软件组件映射到各个ECU上，然后借助系统配置生成器生成系统配置描述文件。这个描述文件包括总线映射之类的所有系统信息以及软件组件与某个ECU的映射关系。
3. 提取特定ECU的描述
   
   从系统配置描述文件中提取出与各个ECU相关的系统配置描述信息，提取的信息包括ECU通信矩阵、拓扑结构、映射到该ECU上的所有软件组件，并将这些信息放在各个ECU的提取文件中。
4. ECU配置
   
   ECU配置主要是为该ECU添加必要的信息和数据，如任务调度、必要的基础软件模块及其配置、运行实体及任务分配等，并将结果保存在ECU配置描述文件中，该文件包含了属于特定ECU的所有信息，换言之，ECU上运行的软件可根据这些信息构造出来。
5. 生成可执行文件
   
   根据ECU配置描述文件中的配置信息，生成RTE和基础软件配置代码，完成基础软件和软件组件的集成，最终生成ECU的可执行代码。

---

## 四、基础软件层

AUTOSAR软件体系结构包含了完全独立于硬件的应用层（Application Layer）和与硬件相关的基础软件层（Basic Software,BSW），并在两者中间设立了一个运行时环境（Run Time Environment），从而使两者分离，形成了一个分层体系架构。一方面，OEM可以专注于开发特定的、有竞争力的应用层软件（位于RTE之上），另一方面，它使OEM所不关心的基础软件层（位于RTE之下）得到标准化。基础软件层（BSW）的结构如下图所示。
![](https://s2.loli.net/2022/10/09/zAGT4VSdXgEcJHF.png)

我们需要做的就是专注于微控制器抽象层的适配

基础软件层主要包括四部分：微控制器抽象层（MCAL），ECU抽象层，服务层以及复杂驱动。其中微控制器抽象层包含了跟硬件相关的驱动程序，可以用来访问内存、通信和I/O等；ECU抽象层负责提供统一的访问接口实现对通信、内存或者I/O的访问，从而无须考虑这些资源由微处理器提供还是由外部设备提供；服务层提供各种类型的后台服务，例如网络服务、内存管理和总线通信服务等，操作系统就位于这一层。
AUTOSAR基础软件层主要用于提供基础软件服务，包括标准化的系统功能以及功能接口，并且由一系列的基础服务软件组件构成，包括系统服务、内存服务、通信服务等，如下图所示。

![](https://s2.loli.net/2022/10/09/JPyL6S8wXHjz3qE.png)

基础软件层的组件及其功能对应如下：

1. **系统：**提供标准化的规定（针对操作系统、定时器以及错误存储器）、ECU特定的服务（ECU状态管理、看门狗管理）和库函数；
2. **内存：**对内部和外部的内存（非易失性存储器）的访问入口进行标准化；
3. **通信：**对汽车网络系统、ECU通信系统以及ECU内部软件的访问入口进行标准化；
4. **输入/输出：**对传感器、执行器以及ECU外设的访问入口进行标准化；

**同时，基础软件层模块按照类型可以分为驱动模块、接口模块、处理模块以及管理器。**

1. ***<u>驱动模块</u>***
   
   驱动模块包含了控制和使用内部或者外部器件的功能，分为内部驱动和外部驱动
   - 内部驱动
   
   内部器件位于微控制器（单片机）的内部，比如内部EEPROM、内部CAN控制器、内部ADC模块等。
   
   内部驱动程序就是针对单片机内部器件资源的驱动程序，这部分驱动程序属于微控制器抽象层（MCAL）
   - 外部驱动
   
   外部器件是指单片机外部的ECU硬件，比如外部EEPROM、外部看门狗、外部Flash等。外部驱动程序就是针对单片机外部硬件资源的驱动程序，属于ECU抽象层。外部驱动程序需要通过微控制器抽象层（MCAL）驱动程序来实现对外部器件的驱动。这种方法下AUTOSAR也支持嵌入在系统基础芯片（SBCs）中的组件，像收发器以及看门狗等。例如，使用SPI通信接口的外部EEPROM驱动程序是通过SPI总线处理程序来驱动外部EEPROM的。但是有一种例外，对于和内存映射相关的外部器件（如外部Flash存储器），其驱动程序是可以直接对微控制器进行存取访问的，所以这部分驱动程序属于微控制器抽象层（MCAL）。
2. ***<u>接口模块</u>***
   
   接口模块包含了对其次级模块进行抽象的功能，比如对一个特定功能的硬件进行抽象。它提供一个通用的接口函数（API）来访问一种特定的器件类型，且与该类型器件的数目无关，同时也与器件的具体硬件实现无关。
   
   接口模块不会改变数据的内容。一般来说，接口属于ECU抽象层。例如，CAN通信系统的接口模块提供一个通用的接口函数来访问CAN通信网络，并且与ECU上CAN控制器的数目以及硬件实现无关。
3. <u>***处理模块***</u>
   
   处理模块是一个专用的接口，它控制一个或多个客户端对一个或多个驱动程序进行并行、多重以及异步地访问。也就是说，它起着缓冲、队列、仲裁以及多路复用的功能。同时，处理程序也不会改变数据本身的内容。处理模块通常会并入驱动程序或是接口模块中（如SPIHandlerDriver、ADC Driver等）。
4. ***<u>管理器</u>***
   
   管理器为多重的客户端提供特定的服务。当单纯的处理程序不能满足对多重的客户端进行抽象时，就需要用到管理器来进行处理。除了处理功能外，管理器还可以对数据内容进行评估、改变或是适应数据内容。
   
   一般而言，管理器属于服务层。例如，非易失性随机存储器（NVRAM）的管理器负责对内部或是外部存储设备进行并行的访问，如Flash、EEPROM存储器等。同时，它也可以完成分布式并且可靠的数据存储、数据校验以及默认值的规定等。

## 五、微控制器层（MCAL）

微控制器抽象层位于AUTOSAR分层模型中BSW最底层，包含内部驱动，可以直接访问微控制器和片内外设。更进一步地，MCAL又可以分为微控制器驱动、存储器驱动、通信驱动和I/O驱动四个部分，各部分又由具体的与微控制器硬件相对应的驱动模块组成。如下图所示。

![](https://s2.loli.net/2022/10/09/dAV6owFhNErL7pl.png)

![](https://s2.loli.net/2022/10/09/1nZj3lLBX7IpKSF.png)

### 1.微控制器驱动

微控制器驱动由**通用定时器驱动（General Purpose Driver,GPT Driver）**、**看门狗驱动（Watchdog Driver,WDG Driver）**、**微控制器单元驱动（Microcontroller Unit Driver,MCU Driver）**和内**核测试（Core Test）**四个部分组成。

1. GPT Driver
   
   在AUTOSAR中有两类定时器，操作系统定时器和硬件定时器。该模块使用通用定时器单元的硬件定时器通道，为操作系统或者其他基础软件模块提供计时功能。GPT驱动的作用是：
   - 启动和停止硬件定时器；
   - 得到定时器数值；
   - 控制时间触发的中断；
   - 控制时间触发的中断唤醒。
2. WDG Driver
   
   WDG Driver的功能主要是初始化和触发看门狗。WDG Driver有内部WDG Driver和外部WDG Driver。内部WDG Driver控制MCU的内部看门狗定时器，提供触发功能和模式选择服务；外部WDG Driver控制外部硬件看门狗，与内部WDG Driver一样，提供触发功能和模式选择服务。
3. MCU Driver
   
   MCU Driver位于MCAL层，可以直接访问微控制器硬件，它的主要功能是初始化、休眠、复位微控制器以及提供其他MCAL软件模块所需的与微控制器相关的特殊功能。MCU Driver还能够使能并设置MCU时钟，例如CPU时钟、外围器件时钟、预分频器等参数。
4. Core Test
   
   Core Test（内核测试）模块包含周期性测试和启动测试。内核测试模块可以对CPU所有寄存器进行测试，提供中断控制和异常检测。该模块还对算术逻辑单元、存储保护单元和缓存控制器等进行检测。

### 2.存储器驱动

存储器驱动由**内部EEPROM驱动**、**内部Flash驱动**、**RAM测试**和**Flash测试**四部分组成。

1. 内部EEPROM驱动
   
   内部EEPROM驱动提供初始化服务，以及对内部EEPROM的读写、写、擦除等操作。**==该驱动模块一次只能接受一个任务。==**
2. 内部Flash驱动
   
   内部Flash驱动提供内部Flash初始化服务，以及对内部Flash的读、写、擦除等操作。该驱动还可以将Flash访问代码下载到RAM中，如果需要的话，也可以执行写、擦除操作。
3. RAM测试
   
   RAM测试模块通过软件对RAM存储进行测试。该模块包含后台测试和前台测试。其中，后台测试是异步服务，前台测试是同步服务。
4. Flash测试
   
   flash测试模块提供算法来测试诸如数据/程序闪存、程序SRAM等非易失性存储器，这些存储器可以是集成在微控制器内部的，也可以是外部映射到微控制器的存储器。

### 3.通信驱动

通信驱动由**以太网（Ethernet）驱动**、**FlexRay驱动**、**CAN驱动**、**LIN驱动**和**SPI驱动**五部分组成。

1. Ethernet Driver
   
   Ethernet驱动模块为以太网提供统一的接口。该驱动模块对所使用的以太网控制器的硬件特性进行了抽象。以太网接口模块使用以太网驱动层访问某些控制器。以太网驱动层由若干个以太网驱动模块组成。如下图所示。
   
   ![](https://s2.loli.net/2022/10/09/ugvi8pfaBLdqjXb.png)
2. FlexRay Driver
   
   FlexRay驱动用来抽象不同的FlexRay通信控制器及其硬件相关的特性。通信控制器的FlexRay协议强制特性经过封装后只能通过统一的API进行访问。API提供了映射到基于实际通信控制器的硬件访问序列的抽象功能操作。因此，使用FlexRay驱动可以保证FlexRay接口独立于硬件。
   
   对内部或外部FlexRay通信控制器的驱动来说，需要进行下列处理：
   - FlexRay控制器的初始化；
   - 配置数据处理单元；
   - 控制指令向通信控制器的传递；
   - 从协议引擎到控制器主接口状态数据的规定；
   - 通信控制器和主处理机之间信息数据的传输。
3. CAN Driver
   
   CAN驱动针对的是微控制器内部的CAN控制器，它可以实现以下功能：
   - 对CAN控制器进行初始化；
   - 发送和接收报文；
   - 对报文的数据和功能进行通知（对接收报文的指示、对发送报文的确认）；
   - 溢出和错误处理；
   - 唤醒检测;
   
   此外，CAN驱动还具有以下特性：**单个或多个CAN通道**、**CAN驱动的多重实例化**、**对接收报文的中断/轮询模式**。
   
   CAN驱动是MCAL的一部分，可以执行硬件访问、向上层提供独立于硬件的API，而==仅有的能够访问CAN驱动的上层是CAN接口（CAN Interface）==。CAN驱动也可以为数据传输的初始化和通知接收事件的回调函数提供服务，该服务也是独立于硬件的。除此之外，CAN驱动也可以控制从属于同一个CAN硬件单元的CAN控制器的行为和状态。
4. LIN Driver
   
   LIN驱动使用标准的通用异步收发器（Universal Asynchronous Receiver Transmitter,UART）或者串行通信接口（Serial Communication Interface,SCI）进行通信。
   
   该模块可以完成以下任务：
   - LIN硬件的初始化；
   - 调度表的处理；
   - LIN报文的发送（通过标志位和函数接口确认）；
   - LIN报文的接收（通过标志位和函数接口指示）；
   - 睡眠和唤醒；
   - 协议差错的处理；
   - 报文的超时监测。
   
   LIN驱动也是MCAL的一部分，可以执行硬件访问、向上层提供独立于硬件的API。==仅有的能够访问LIN驱动的上层是LIN接口（LIN Interface）==。==一个LIN驱动可以支持多个通道，但是这些通道要属于同一个LIN硬件单元。==
5. SPI Driver
   
   SPI驱动模块是微控制器内部同步通信串行接口的驱动。SPI驱动为SPI总线上不同的设备（如EEPROM/Watchdog等）提供读写访问服务。一个SPI设备可以被所使用的SPI硬件和相关的片选信号识别。该模块可以在主、从或者主-从模式下运行。
   
   配置SPI驱动应遵循以下步骤：
   - 选择SPI驱动的功能级别，配置可选择的功能特性；
   - 根据数据用途来定义SPI通道，它们可以是SPI驱动的内部缓冲器，或者是由用户提供的外部缓冲器；
   - 根据硬件属性来定义SPI任务，它们会包含一系列使用这些属性的通道；
   - 定义任务序列，以优先级排序的方式来传递数据。

### 4.I/O驱动

I/O驱动由**PORT驱动**、**DIO驱动**、**ADC驱动**、**PWM驱动**、**ICU驱动**、**OCU驱动**六部分组成。

1. PORT Driver
   
   PORT驱动初始化就是对微控制器的整个PORT模块进行初始化配置。
   
   很多端口和管脚被分配有多种不同的功能，即可以进行引脚功能复用，比如通用I/O、模数转换、脉宽调制等功能。因此，对PORT必须有一个整体的配置和初始化，对各管脚的具体配置和使用取决于微控制器和ECU的引脚功能分配。PORT初始化数据应当尽可能高效地写到每个端口。**DIO驱动中所用到的端口的配置和初始化都是在PORT驱动模块中完成的。因此，在使用DIO功能之前，应先进行PORT的初始化。**
2. DIO Driver
   
   DIO驱动对微控制器硬件管脚的访问进行了抽象，除此之外，还可以对管脚进行分组。该模块通过DIO通道、DIO端口以及DIO通道组来读写数据，而且这类操作是同步的。
3. ADC Driver
   
   ADC驱动对微控制器内部模数转换单元进行初始化和控制。它可以提供启动和停止模数转换的服务，分别用来开启和禁用模数转换的触发源。
4. PWM Driver
   
   PWM驱动为微控制器PWM模块提供初始化和控制服务，可生成周期和占空比都可变的脉冲。
5. ICU Driver
   
   ICU驱动控制的是微控制器的输入捕获单元（Input Capture Unit），有两种模式：正常模式和休眠模式。
   
   ICU驱动可以提供以下服务：
   - 信号边沿检测及通知；
   - 中断唤醒；
   - 周期性信号时间的测量；
   - 边沿时间戳捕获；
   - 边沿/脉冲计数
6. OCU Driver
   
   OCU驱动的作用是对微控制器内部的输出比较单元（Output Compare Unit）进行初始化和控制。当计数器的值到达某个阈值时，OCU模块会自动开始比较并执行相应的操作。
   
   OCU驱动还可以为下列功能提供服务：
   - 启动或停止输出通道；
   - 设定某个阈值；
   - 启用或禁用某个通道的通知函数；
   - 获取计数器数值；
