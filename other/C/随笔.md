# 随笔

## 1.位域

有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。

在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域，位段成员的类型必须指定为`unsigned`或`int`类型。请看下面的例子：

```c
struct bs{
    unsigned m;
    unsigned n: 4;
    unsigned char ch: 6;
};
```

`:`后面的数字用来限定成员变量占用的位数。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、ch 被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6 位（Bit）的内存。

### 1.1位域的存储规则

位域的具体存储规则如下：

1.  当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。
    以下面的位域 bs 为例：

    ```c
    #include <stdio.h>
    int main(){
        struct bs{
            unsigned m: 6;
            unsigned n: 12;
            unsigned p: 4;
        };
        printf("%d\n", sizeof(struct bs));
        return 0;
    }
    ```

    运行结果：4

    m、n、p 的类型都是 unsigned int，sizeof 的结果为 4 个字节（Byte），也即 32 个位（Bit）。m、n、p 的位宽之和为6+12+4 = 22，小于 32，所以它们会挨着存储，中间没有缝隙。

    >   sizeof(struct)的大小之所以为 4，而不是 3，是因为要将内存对齐到 4 个字节，以便提高存取效率

2.  如果成员之间穿插着非位域成员，那么不会进行压缩。例如对于下面的 bs：

    ```c
    struct bs{
        unsigned m: 12;
        unsigned ch;
        unsigned p: 4;
    };
    ```

    在各个编译器下 sizeof 的结果都是 12。

### 1.2无名位域

位域成员可以没有名称，只给出数据类型和位宽，如下所示：

```c
struct bs{
    int m: 12;
    int  : 20;  //该位域成员不能使用
    int n: 4;
};
```

无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。

上面的例子中，如果没有位宽为 20 的无名成员，m、n 将会挨着存储，sizeof(struct bs) 的结果为 4；有了这 20 位作为填充，m、n 将分开存储，sizeof(struct bs) 的结果为 8。

