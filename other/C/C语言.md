# C语言

[toc]



## C和指针
### 基本概念

#### 代码编译过程

1. 预处理器处理
    1. 用实际值代替#define指令定义
    2. 读入由#include指令包含的文件内容
2. 源代码解析
3. 产生目标代码



#### 程序执行过程

1. 程序必须载入到内存中
2. 执行
    1. 程序将使用一个运行时堆栈(用于储存函数的局部变量和返回值地址)
    2. 程序也能使用静态(static)内存,储存在静态内存中的变量在程序的整个执行过程中将一直保存他的值



#### 关键字

```c
auto　 		do　 	   goto　 	signed 		unsigned
break　 		double 		if　 	sizeof 		void
case　 		else　 		int　 	static 		volatile
char　 		enum　 		long　 	struct 		while
const　 		extern 		register　switch
continue 	float 		return　   typedef
default 	for　 		short　 	union
```



#### 编程规范

1. 空行用于分隔不同的逻辑代码段，它们是按照功能分段的
2. if和相关语句的括号是这些语句的一部分，而不是它们所测试的表达式的一部分,在括号和表达式之间留下一个空格,使表达式看上去更突出一些,函数原型也是如此
3. 在绝大多数操作符的使用中，中间都隔以空格，这可以使表达式的可读性更佳,在复杂的表达式中，可以省略空格，这有助于显示子表达式的分组
4. 嵌套于其他语句的语句将缩进，以显示它们之间的层次
5. 绝大部分注释都是成块出现的，这样它们从视觉上在代码中很突出
6. 在函数的定义中，返回类型出现于独立的一行中，而函数的名字则在下一行的起始处



### 数据类型

---

#### 基本数据类型

- 整形

    - 字符
        - char			0~127
        - signed char     -127~127
        - unsigned char   0~255
    - 短整型
        - short int       -32767~32767
        - unsigned int    0~65535
    - 整形
        - int             -32767~32767
        - unsigned int    0~65535
    - 长整型
        - long int	    -2147483647~2147483647
        - unsigned long   0~4294967295

    长整型至少和整形一样长，整形至少和短整形一样长

- 浮点型

- 指针

- 聚合类型

---

只有当程序所使用的char型变量的值位于signed char和unsigned char的交集中，这个程序才是可移植的。



在一个把字符当作小整型值的程序中，如果显式地把这类变量声明为signed或unsigned，可以提高这类程序的可移植性。



#### 指针

> 变量的值存储于计算机的内存中，每个变量都占据一个特定的位置。每个内存位置都由地址唯一确定并引用，就像一条街道上的房子由它们的门牌号码标识一样。指针只是地址的另一个名字罢了。指针变量就是一个其值为另外一个（一些）内存地址的变量



##### 1.指针常量

C语言内部并没有特地定义这个概念

##### 2.字符串常量

`字符串`：它就是一串以NUL字节结尾的零个或多个字符

---

#### 基本声明

声明格式

```
说明符(一个或多个)  声明表达式
```

`注意`:signed关键字一般只用于char类型，因为其他整型类型在缺省情况下都是有符号数。至于char是否是signed，则因编译器而异。所以，char可能等同于signed char，也可能等同于unsigned char.

---

#### 初始化

在一个声明中，你可以给一个标量变量指定一个初始值，方法是在变量名后面跟一个等号（赋值号），后面是你想要赋给变量的值

---

#### 数组

> 如果下标值是从那些已知是正确的值计算得来，那么就无需检查它的值。如果一个用作下标的值是根据某种方法从用户输入的数据产生而来的，那么在使用它之前必须进行检测，确保它们位于有效的范围之内。

---

#### 声明指针

>在C语言的声明中，先给出一个基本类型，紧随其后的是一个标识符列表，这些标识符组成表达式，用于产生基本类型的变量



例如:

```c
int *a;		//声明一个指向int型的指针a
```



```c
int* a;		//同样是声明一个指向int型的指针
```



```c
int* b,c,d;	//声明一个指针和两个整形
```

>人们很自然地以为这条语句把所有三个变量声明为指向整型的指针，但事实上并非如此。我们被它的形式愚弄了。星号实际上是表达式*b的一部分，只对这个标识符有用。b是一个指针，但其余两个变量只是普通的整型



在声明指针变量时，你也可以为它指定初始值。这里有一个例子，它声明了一个指针，并用一个字符串常量对其进行初始化：

```c
char *message = "Hello world!";
```

`警告`:

>这种类型的声明所面临的一个危险是你容易误解它的意思。在前面一个声明中，看上去初始值似乎是赋给表达式*message，事实上它是赋给message本身的。换句话说，前面一个声明相当于：



```c
char *message;
message = "Hello World!";
```



---

#### typedef

>C语言支持一种叫作typedef的机制，它允许你为各种数据类型定义新名字。typedef声明的写法和普通的声明基本相同，只是把typedef这个关键字出现在声明的前面

例如:

```c
typedef char *ptr_to_char;
```

这个声明把标识符ptr_to_char作为指向字符的指针类型的新名字。你可以像使用任何预定义名字一样在下面的声明中使用这个新名字

```c
ptr_to_char a;
```

`注意`:你应该使用typedef而不是#define来创建新的类型名，因为后者无法正确地处理指针类型。

例如:

```c
#define　d_ptr_to_char　 char *
d_ptr_to_char　 a, b;
```

在这个语句中,#define展开之后变成了

```c
char* a,b;
```

>正确地声明了a，但是b却被声明为一个字符。在定义更为复杂的类型名字时，如函数指针或指向数组的指针，使用typedef更为合适。

---

#### 常量

ANSI C允许你声明常量，常量的样子和变量完全一样，只是它们的值不能修改。你可以使用const关键字来声明常量

例如:

```c
int const a;
const int a;
```

> 在函数中声明为const的形参在函数被调用时会得到实参的值

涉及指针的常量

> 因为有两样东西都有可能成为常量——指针变量和它所指向的实体

例如:

```c
int *pi;			//这是一个指向整形的指针
int const *pci		//这是一个指向整形常量的指针,你可以修改指针的值,但是你不能修改它所指向的常量的值
int *const cpi		//cpi是一个指针常量,指针的值不允许修改,但是它指向的值可以改变
int const *const cpci //指针和指向的数据都不能被改变
```

>当你声明变量时，如果变量的值不会被修改，你应当在声明中使用const关键字。这种做法不仅使你的意图在其他阅读你的程序的人面前得到更清晰的展现，而且当这个值被意外修改时，编译器能够发现这个问题。

而#define指令是另一种创建名字常量的机制

---

#### 作用域

##### 代码块作用域

位于一对花括号之间的所有语句称为一个代码块。任何在代码块的开始位置声明的标识符都具有代码块作用域(block scope)，表示它们可以被这个代码块中的所有语句访问.



### 问题

1. 把一个大型程序放入一个单一的源文件中有什么优点？有什么缺点？
    - 优点
        - 避免一些声明
        - 避免重定义
        - 链接时间相对较少
    - 缺点
        - 代码较难维护
        - 不利于后续阅读
        - 修改某个模块的代码导致整个工程都要重新编译

